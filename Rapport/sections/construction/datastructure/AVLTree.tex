\subsubsection{AVL}
In this project the name of the rotation direction is based on the which subtree side has the most nodes. This means that in the previous example, a right rotation was needed that would have rotated the right subtree 1 step to the left. The opposite happens in a left rotation, to many nodes in the left subtree, will make it rotate in the right direction. In some circumstances a dobbel rotation is needed. These on the other hand are named after the last direction you need to rotate the nodes in order to balance the subtree. Dobbel left rotation means that a rotation forwards the right is first used on the right child of the node causing the imbalance. This will essentially switch the right childs spot with the imbalanced node. Then followed by a rotation on the new imbalanced node forwards the left. The opposite will occur on a double right rotation. 
\begin{figure}[H]
	\centering
	\includegraphics[width=0.90\linewidth]{/trees/AVLTreesVer2}	
	\caption{The figure displays 2 unbalanced binary search trees and a fully balanced AVL tree. }
	\label{fig:AVLTrees}
\end{figure}
\noindent
An example of balanced and unbalanced BSTs can be seen in the figure \ref{fig:AVLTrees}. The left tree is a BST that has to many nodes in the left subtree. The center tree is a BST that has to many nodes in the right subtree. The tree to the right in the figure is a fully balanced BST, which makes it qualified as an AVL tree. The red letters represent the height of the node's children. The value is determined by how many nodes there are between the leaf nodes to the selected node. The blue dotted lines marks the subtree that breaks the AVL condition.
\\[11pt]
The function createAVLTreeSolution creates an AVL tree used as the solution object for a question. The functionality is mostly the same as the createBinarySearchSolution function mentioned earlier, however some extra functionality was needed in order to balance out the tree. If an existing is given, the tree given needs to be fully balanced before any insertions or deletions can be done to the tree. Once the existing tree is balanced or no existing tree was given, the values in the added array will be inserted in the tree. Just like in createBinarySearchSolution, removing nodes from a tree requires that an existing tree is given. After every insertion and deletion, the tree will once again have to be checked whether or not its still balanced. If the tree is not balanced, the tree will have to rotated in order to rebalance itself. The rotation is determined by which subtree has currently the most nodes. Not to mention insertion and deletion requires different set up when it comes to using normal rotation or double rotations. The returning array from the "createAVLTreeSolution" is used and has the same format as in the "createBinarySearchSolution" function. The only noticeable difference is that the array for the "createAVLTreeSolution" also need to store the tree state after any rotations have been performed.
\\[11pt]
Because the Tree class contained circular references between parent node and child nodes, it proved difficult to store solution BST and AVL trees into the database. This was because it wasn't possible to convert the tree object to JSON, since JSON can't handle circular references. This means that the circular references had to be removed before the solution could be stored in the database. To solve this an export function was developed for the tree class. The export function would remove the circular references by turning the parent reference into the parent's node value. Once the parent reference is gone the tree object were able to be turned into a JSON format. Of course, since the solution checker requires BST and AVL trees to be in a certain format, an import function also needed to be used to convert the tree object back to its original form. The import function has 2 tasks. The first task is to replace all null value in the with an undefined value. The second job is to reinsert the proper parent reference to each node in the tree. This is simply done by traversing the tree and remember the previous visited node as the current node's parent. Once this is done the solution object can be checked with the converted Tree the students drew with the GraphDrawer and see if they match or not. If the question revolved around removing nodes, then the converted Tree only needs to match on of the trees in the solution object.


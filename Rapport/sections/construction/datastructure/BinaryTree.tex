\subsubsection{BinaryTree}
Most of the student tasks involving binary trees usually involve drawing a resulting binary tree. In order to avoid giving the students help with drawing a correct binary tree structure, the GraphDrawer was designed in a way that lets them mix between drawing tree structures and graph structures. However, this meant that multiple extra criteria needed to be considered when checking the students work with the solution. It was necessary to implement a JavaScript class, \code{Tree}, for representing the binary trees drawn and \code{BinaryTreeNode}, representing every node in the tree. These classes were designed in a way such that they can be used in all the taught binary tree structures in the Algorithms and Data Structures course. These are the standard binary tree, binary search tree (BST), and AVL tree. 
\\[11pt]
The \code{Tree} class consists of a root node referencing the node at the start of the tree, and an array of all the current nodes in the tree, this also includes the root node. The \code{BinaryTreeNode} class consists of the node's value and an array containing the node's child nodes. A notable design choice was that each binary node and all their children nodes are stored in arrays. The tree has an array of all current nodes in the tree, where index 0 is the root node. In addition, all nodes have an array containing references to its children nodes. Normally a tree structure would have only needed to have an independent variable referencing the two different child nodes. However, because students can draw any tree, it was a better option to store the children references in arrays instead. The reason for this was because a student had the option to draw a tree with more than 2 children, which is not allowed in a binary tree structure. Arrays also do not cause any problems with distinguishing the different child nodes either since the nodes will be divided properly using different placement indexes. A left child node will always be located at index 0 and a right child node will always be located at index 1. If there are more than 2 children nodes in the array, then the binary tree criteria are not fulfilled, and therefore will not be accepted as a valid tree object. Multiple functions were implemented to not only transform the drawn tree to a Javascript tree object, but also to check whether or not the created Javascript object is qualified as the chosen binary tree structure. Additional inbuilt class functions for both the tree class and node class were needed for certain tree interactions. For instance, when storing the current tree as a step, a function for duplicating the tree was implemented.
\\[11pt]
Because the binary tree has very few restrictions, creating a solution tree object for the data structure proved challenging. Unlike the BST and AVL tree structures, the binary tree only required each node to have a single parent and have no more than two children. Therefore the order of the nodes in the tree does not matter. The solution checker for the binary tree was therefore set up so that it checked the nodes in the students binary tree and compared it to the list of nodes demanded in the question. If the student delivered a binary tree that either did not have the required nodes or broke any of the binary tree conditions, then the answer would be incorrect. In any other case, the student will get the answer correct. This means that the solution object stored in the database is an array of the nodes wanted in the binary tree.
\subsubsection{BinaryTree}
Most of the student tasks involving binary tree, usually involves drawing a resulting binary tree. In order to avoid giving the students help with drawing a correct binary tree structure, the graph drawer was designed in a way that lets them mix between drawing tree structures and graph structures. However, this essentially meant that multiple extra criterias  needed to be considered when checking the students work with the solution. It was necessary to implement a Javascript class Tree for representing the binary trees drawn and a Binary Node class representing every node in the tree. These classes were designed in a way that they could be used in all the taught binary tree structures in the Algorithms and Data Structures course. This being the normal binary tree structures, binary search tree structures and AVL binary tree structures. 
\\[11pt]
The Tree class consists of a root node referencing the node at the start of the tree, and an array of all the current nodes in the tree, this also includes the root node. The Binary Node class consists of the node's value and an array containing the node's child nodes. A notable design choice chosen was that each binary node and all their children nodes are stored in arrays. The tree has an array of all current nodes in the tree, where index 0 will be the root node. In addition all nodes have an array containing references to its children nodes. Normally a tree structured would have only needed having an independent variable referencing the two different child nodes, however because students could essentially draw any kind of tree, it was a better option to store the children references in arrays instead. The reason this was because a student had the option to draw a tree with more than 2 children, which is not allowed in a binary tree structure. Arrays also doesn't cause any problems with distinguishing the different child nodes either since the nodes will be divided properly using different placement indexes. Left child will always be located at index 0 and the right child node will always be located at index 1. If there are more than 2 children nodes in the array, then the binary tree criterias are not fulfilled, and therefore will not be accepted as a valid tree object. Multiple functions were implemented to not only transform the drawn tree to a Javascript tree object, but also to check whether or not the created Javascript object is qualified as the chosen binary tree structure. Additional inbuilt class functions for both the tree class and node class were needed for certain tree interactions. For instance, in order to avoid problems with overwriting old tree structures when the program required a new tree with the same property as the old was needed, a duplicate tree function was added to the tree class.\\[11pt]
Because the normal binary tree has very few restrictions, creating a solution tree object for these data structures proved difficult. Unlike the BST and AVL tree structures, binary tree only required each node to have only a single parent and have no more than 2 children. Therefore the order of the nodes in the tree doesn't matter. The solution checker for binary tree was therefore set up so that it checked the nodes in the students binarytree and compared it to the list of nodes demanded in the question. If the student delivered a binary tree that either didn't have nodes required or broke any of the binary tree conditions, then the answer would be incorrect. In any other case the student will get the correct answer. After each binary tree question has concluded the solution shown on projector will just be a message that would inform the student that the answer would be correct if they drew a legal binary tree with the nodes specified. This means that the solution object stored in the database is only an array of the nodes wanted in the binary tree.
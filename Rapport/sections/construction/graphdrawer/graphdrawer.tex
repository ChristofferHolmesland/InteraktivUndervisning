\subsection{GraphDrawer}
To solve the problem of letting students visually answer questions, GraphDrawer was created. GraphDrawer is the name of a VueJS component which is used to display graphics to the user. It is implemented as an software engine (https://en.wikipedia.org/wiki/Software\_engine), which means that it is responsible for rendering the world and handling user interaction. 
\\[11pt]
The world consists of two types of entities, nodes (vertices) and edges. Entities are stored in arrays on the GraphDrawer object. Nodes are drawn as either a circle or a square. A node needs to specify its position in the world, which is stored on the node object as the properties \code{x} and \code{y}. It also needs to store information about how large it is, which is stored in the \code{r} property. \code{r} represents either the circle radius, or the length of each side of the square. A node needs a value, stored in the \code{v} property. This can be text, a number, or a combination of text and numbers. GraphDrawer will only render nodes if they have the \code{x}, \code{y}, \code{r} and \code{v} properties. There are also several optional properties a node can have. \code{selected} is a boolean used by a controller to indicate whether a node has been selected (\code{true}) or not (\code{false}). \code{culled} is a boolean used by the camera to indicate whether a node has been culled (\code{true}) or not (\code{false}). \code{fillColor} decides what color will be used to render the inner part of the node. If it's undefined, white will be used. \code{strokeColor} decides  what color will be used to render the outline of a node. If it's undefined, black will be used. Edges are used to link nodes together. An edge needs to have two properties, \code{n1} and \code{n2}, which are references to the nodes being linked by the edge. Edges are drawn as either a line or an arrow, between the two nodes. If the edge has the property \code{directed} with the value \code{true}, an arrow will be drawn pointing from \code{n1} at \code{n2}. If \code{directed} is \code{false} or \code{undefined}, a line is drawn. The \code{strokeColor} property decides which color will be used to draw the line/arrow. If it's undefined, black is used. An edge can also have the \code{v} property. \code{v} represents the cost of going from \code{n1} to \code{n2} (and from \code{n2} to \code{n1} if \code{directed} is \code{undefined} or \code{false}). \code{v} should be a number, and its value will be drawn next to the line/arrow.
\\[11pt]
To render the world, three objects are needed, the world, a camera and a HTML5 canvas. The world has information about the entities. The camera is used to decide which entities need to be drawn to the canvas. These objects are needed because the world might be larger than what is possible to display on a single webpage. The canvas decides how much of the webpage is used to render the world. The camera can then be moved around to display different parts of the world. When the GraphDrawer starts, an interval is started which lets the GraphDrawer update 60 times every second. Each time the GraphDrawer has the opportunity to update, is called a frame. Because the application is designed to be used by both phones and computers, computationally expensive and time consuming operations should be avoided if possible. For this reason the GraphDrawer will often discard frames. Discarding frames means that no operation is performed, even though the opportunity to do something was there. The update function is called once per frame. If the \code{dirty} property is \code{false}, the frame is discarded. The GraphDrawer will only set the \code{dirty} property to \code{true} once, at startup, so the initial state is rendered. Afterwards a controller has to tell the GraphDrawer to not discard the next frame by setting \code{dirty} to \code{true}. The \code{dirty} property makes it possible to have a responsive user interface, and save CPU time at the same time. When a frame isn't discarded, the world will be redrawn. This is done in several steps:
\begin{enumerate}
    \item The canvas is cleared. This is done to prevent entities to appear at two positions at the same time.
    \item Nodes and edges are drawn to a drawing buffer (\code{drawBuffer}). This is done by the GraphDrawer.
    \item The user interface is drawn to a separate buffer (\code{staticBuffer}). This is done by the GraphDrawer if the \code{operatingMode} is set to \code{Presentation}, or by a controller if the \code{operatingMode} is set to \code{Interactive}. \code{operatingMode} is used by the GraphDrawer and by controllers to decide what kind of user interaction is allowed.
    \item \code{drawBuffer} and \code{staticBuffer} is drawn to the canvas.
\end{enumerate}
The drawing buffer is used to prevent screen tearing (https://en.wikipedia.org/wiki/Screen\_tearing). By using a seperate buffer for drawing, the user will be shown a complete image of the world at every frame, instead of one which is in the process of being drawn. Another buffer is used by the user interface because it makes it easier to draw the interface on top of the world, by simply placing the draw statement after the world draw statement. The \code{staticBuffer} uses canvas coordinates to draw, which needs less operations to consistently place the interface inside the cameras view.
\\[11pt]
To let the user interact with the world two event listeners are attached to the canvas. \code{mousedown} is used to respond to mouse clicks, and \code{touchstart} is used by touch screens. These listeners use the same callback function. The callback function will pass the event to the right handler, depending on handler priority. A handler is a function which takes the event as an argument, and returns whether it consumed the event. If the event was consumed, it should not be given to any other handler. The priority of the user interface handler should generally be higher than the world handler, but the order is not forced. The GraphDrawer will first check if the user interacted with one of the buttons. If not, then a controller will be given the chance to handle the event. Finally, the event is given to the gesture handlers. Gesture handlers are responsible for detecting patterns in user interaction and check if they match a given gesture. The GraphDrawer implements two gestures, pan and zoom. Pan is used to move the camera around the world. A pan gesture happens when the user clicks a mouse button, and moves the pointer without releasing the button. It can also happen if the user drags their finger across the canvas. The movement must be larger than a given threshold before the camera starts moving. A zoom gesture is defined as the user dragging two fingers in opposite directions. If the fingers move towards eachother, the zoom decreases. If the fingers move away from eachother, the zoom increases. The average point between the fingers will remain at the same position relative to the canvas edge. The position of events are stored in different properties of the event object, depending on what type of event it is. To make it simpler to write code that works with all types of events, a helper function \code{setEventOffset} was created to convert event positions to a common format. This function should be used right after recieving a event object, to be sure the position of the event is available in the expected properties..

setEventOffset
\\[11pt]
The controller interface....
\\[11pt]
GraphDrawer configuration...
\\[11pt]
Steps...


\input{sections/construction/graphdrawer/camera.tex}

\input{sections/construction/graphdrawer/controllers/graph0.tex}

\input{sections/construction/graphdrawer/controllers/sort.tex}

\input{sections/construction/graphdrawer/controllers/dijkstra.tex}

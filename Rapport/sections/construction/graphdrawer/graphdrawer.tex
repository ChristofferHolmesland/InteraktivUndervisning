\subsection{GraphDrawer}
To solve the problem of letting students visually answer questions, the GraphDrawer VueJS component was created. GraphDrawer can be included on any page where a graph should be displayed. It is built as a layer on top of the HTML5 Canvas element.
\\[11pt]
The GraphDrawer includes a rendering engine which is responsible for converting a part of the world to a image displayed to the user. A rendering engine is software which generates graphics from data. The world contains everything the user can interact with. The interaction is done through the HTML5 Canvas element. User interaction events are recieved from the canvas element in the form of "The user clicked at this (x, y) position", or "The user currently has two fingers on the screen at (x1, y1) and (x2, y2)". The GraphDrawer needs to convert the screen coordinates to world coordinates, and then decide if the given event at the given world position has any meaning for the state of the world. The coordinate conversion is done by the camera.
\\[11pt]
The world consists of two types of entities, nodes (vertices) and edges. Entities are stored in arrays on the GraphDrawer object. Nodes are drawn as either a circle or a square. A node needs to specify its position in the world, which is stored on the node object as the properties \code{x} and \code{y}. It also needs to store information about how large it is, which is stored in the \code{w} and \code{h} properties. If the node is a circle, then \code{w} and \code{h} should have the same value, and the value should be the circle radius. If it is an ellipse, then the \code{w} is the radius along the x-axis, and the \code{h} is the radius along the y-axis. A node needs a value, stored in the \code{v} property. This can be text, a number, or a combination of text and numbers. GraphDrawer will only render nodes if they have the \code{x}, \code{y}, \code{w}, \code{h} and \code{v} properties. There are also several optional properties a node can have. \code{selected} is a boolean used by a controller to indicate whether a node has been selected (\code{true}) or not (\code{false}). \code{culled} is a boolean used by the camera to indicate whether a node has been culled (\code{true}) or not (\code{false}). \code{fillColor} decides what color will be used to render the inner part of the node. If it's undefined, white will be used. \code{strokeColor} decides  what color will be used to render the outline of a node. If it's undefined, black will be used.
\\[11pt]
Edges are used to link nodes together. An edge needs to have two properties, \code{n1} and \code{n2}, which are references to the nodes being linked by the edge. Edges are drawn as either a line or an arrow, between the two nodes. If the edge has the property \code{directed} with the value \code{true}, an arrow will be drawn pointing from \code{n1} at \code{n2}. If \code{directed} is \code{false} or \code{undefined}, a line is drawn. The \code{strokeColor} property decides which color will be used to draw the line/arrow. If it's undefined, black is used. An edge can also have the \code{v} property. \code{v} represents the cost of going from \code{n1} to \code{n2} (and from \code{n2} to \code{n1} if \code{directed} is \code{undefined} or \code{false}). \code{v} should be a number, and its value will be drawn next to the line/arrow.
\\[11pt]
To render the world, three objects are needed, the world, a camera and a HTML5 canvas. The world has information about the entities. The camera is used to decide which entities need to be drawn to the canvas. These objects are needed because the world might be larger than what is possible to display on a single webpage. The canvas decides how much of the webpage is used to render the world. The camera can then be moved around to display different parts of the world. When the GraphDrawer starts, an interval is started which lets the GraphDrawer update 60 times every second. Each time the GraphDrawer has the opportunity to update, is called a frame. Because the application is designed to be used by both phones and computers, computationally expensive and time consuming operations should be avoided if possible. For this reason the GraphDrawer will often discard frames. Discarding frames means that no operation is performed, even though the opportunity to do something was there. The update function is called once per frame. If the \code{dirty} property is \code{false}, the frame is discarded. The GraphDrawer will only set the \code{dirty} property to \code{true} once, at startup, so the initial state is rendered. Afterwards a controller has to tell the GraphDrawer to not discard the next frame by setting \code{dirty} to \code{true}. The \code{dirty} property makes it possible to have a responsive user interface, and save CPU time at the same time. When a frame isn't discarded, the world will be redrawn. This is done in several steps:
\begin{enumerate}
    \item The canvas is cleared. This is done to prevent entities from appearing at two positions at the same time.
    \item Nodes and edges are drawn to a drawing buffer (\code{drawBuffer}). This is done by the GraphDrawer.
    \item The user interface is drawn to a separate buffer (\code{staticBuffer}). This is done by the GraphDrawer if the \code{operatingMode} is set to \code{Presentation}, or by a controller if the \code{operatingMode} is set to \code{Interactive}. \code{operatingMode} is used by the GraphDrawer and by controllers to decide what kind of user interaction is allowed.
    \item \code{drawBuffer} and \code{staticBuffer} is drawn to the canvas.
\end{enumerate}
The drawing buffer is used to prevent screen tearing. Screen tearing happens when the world is updated in the middle of drawing the world to the canvas. The result is that some parts of the canvas will show the old state of the world, while other parts show the new state. By using a seperate buffer for drawing, the user will be shown a complete image of the world at every frame, instead of one which is in the process of being drawn. Another buffer is used by the user interface because it makes it easier to draw the interface on top of the world, by simply placing the draw statement after the world draw statement. The \code{staticBuffer} uses canvas coordinates to draw, which needs less operations to consistently place the interface inside the camera view.
\\[11pt]
To let the user interact with the world two event listeners are attached to the canvas. \code{mousedown} is used to respond to mouse clicks, and \code{touchstart} is used by touch screens. These listeners use the same callback function. The callback function will pass the event to the right handler, depending on handler priority. A handler is a function which takes the event as an argument, and returns whether or not it consumed the event. If the event was consumed, it should not be given to any other handler. The priority of the user interface handler should generally be higher than the world handler, but the order is not forced. The GraphDrawer will first check if the user interacted with one of the buttons. If not, then a controller will be given the chance to handle the event. Finally, the event is given to the gesture handlers. Gesture handlers are responsible for detecting patterns in user interaction and check if they match a given gesture. The GraphDrawer implements two gestures, pan and zoom. Pan is used to move the camera around the world. A pan gesture happens when the user clicks a mouse button, and moves the pointer without releasing the button. It can also happen if the user drags their finger across the canvas. The movement must be larger than a given threshold before the camera starts moving. A zoom gesture is defined as the user dragging two fingers in opposite directions. If the fingers move towards eachother, the zoom decreases. If the fingers move away from eachother, the zoom increases. The average point between the fingers will remain at the same position relative to the canvas edge. The position of events are stored in different properties of the event object, depending on what type of event it is. To make it simpler to write code that works with all types of events, a helper function \code{setEventOffset} was created to convert event positions to a common format. This function should be used right after recieving a event object, to be sure the position of the event is available in the expected properties.
\\[11pt]
The GraphDrawer constructor takes three arguments, \code{canvas}, \code{locale} and \code{config}. \code{canvas} should be a reference to the HTML Canvas which will be used. \code{locale} should be an object containging references to all of the displayed strings in a given language. \code{config} should be an object containing configuration options. The following is a list of all the configuration options avaiable:
\begin{enumerate}
    \item \code{nodeShape}, determines the shape which will be used to render the nodes. Possible values are \code{"Circle"} and \code{"Rectangle"}. If no value is given, \code{nodeShape} is set to \code{"Rectangle"}.
    \item \code{controlType}, determines which controller will be used by the GraphDrawer. Possible values are the names of the controllers as a string. If no value is given, \code{controlType} is set to \code{"Sort"}.
    \item  \code{operatingMode}, determines if the user can manipulate the world, or view a list of states. Possible values are \code{"Interactive"} and \code{"Presentation"}. If no value is given, \code{operatingMode} is set to \code{"Interactive"}.
    \item \code{displayEdgeValues}, enables the \code{v} (value) property of edges. The value will be drawn next to the edge, and can be modified if the \code{operatingMode} is set to \code{"Interactive"}. If no value is given, \code{displayEdgeValues} is set to \code{true}.
    \item \code{directedEdges}, enables drawing of edges as arrows instead of lines. If it is set to \code{true} then all edges which does not have the \code{directed} property set to \code{false} will be drawn as an arrow instead. If no value is given, \code{directedEdges} is set to \code{false}.
\end{enumerate}
Developers can add or remove features from the GraphDrawer by creating controller objects. Controller objects are used to modify the user interaction, and the world presentation. They can interrupt the GraphDrawer at pre-determined states. It is also possible to create their own interrupts by creating timers (\code{setTimeout}, \code{setInterval}) or by adding event handlers to the canvas object. The controller interface is simple by design and only requries two methods. There are also some optional methods which can be implemented to add more functionality.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{/graphdrawer/controllerlifecycle}
    \caption{Graphdrawer - controller interaction}
    \label{fig:graphdrawerControllerLifeCycle}
\end{figure}
\begin{enumerate}
    \item Required: The controller constructor. The constructor should take two arguments. The first being a reference to the GraphDrawer, and the second being an optional configuration object.
    \item Required: \code{export()}, should return an object. The \code{export} method is called when the system wants to retrieve an answer or solution from the GraphDrawer. The returned object should be a representation of the world, which can be understood by one of the algorithm implementations, or by a solution checker function.
    \item Required: \code{mouseDownHandler(e)}, should return \code{true} or \code{false}. The \code{mouseDownHandler()} is called when the user clicks or touches the canvas. It is called with the event as the first and only argument. \code{mouseDownHandler()} should return \code{true} if the event was handled and should be consumed, or \code{false} if it was ignored.
    \item Optional: \code{configure()}. If the controller was given a configuration object at instantiation, then the \code{configure()} method should be implemented. This is called when the GraphDrawer changes controller.
    \item Optional: \code{dirtyUpdate()}. \code{dirtyUpdate()} is called right before the world is rendered and drawn to the screen.
    \item Optional: \code{parseSteps()} and the \code{steps} property. If the \code{operationMode} of the GraphDrawer is set to \code{"Presentation"}, then the controller is expected to have a list of steps in the \code{steps} property of the controller. The user can navigate through the list. \code{parseSteps()} is called every time the user changes the viewed step. The index of the viewed step is stored in the GraphDrawer property \code{currentStep}.
\end{enumerate}
Even though the controllers allows for configuration, not all of the configuration can be changed when the GraphDrawer component is included. E.g. Dijkstra start and end colors are defined inside the component, and not as a property on the component. This is done to enforce a consistent style in the application. If it was possible to change the colors every time you included the GraphDrawer on a page, it would be confusing for the users. The colors can be changed in the component definition, but they have to be the same for the whole application.

\input{sections/construction/graphdrawer/camera.tex}

\input{sections/construction/graphdrawer/controllers/graph0.tex}

\input{sections/construction/graphdrawer/controllers/sort.tex}

\input{sections/construction/graphdrawer/controllers/dijkstra.tex}

\input{sections/construction/graphdrawer/controllers/python.tex}

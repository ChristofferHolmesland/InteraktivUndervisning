\subsection{GraphDrawer}
To solve the problem of letting students visually answer questions, the GraphDrawer Vue component was created. GraphDrawer can be included on any page where data structures should be displayed. It is built as a layer on top of the HTML5 Canvas element.
\\[11pt]
The GraphDrawer includes a rendering engine which is responsible for converting a part of the world to an image displayed to the user. The world is where every node and edge is placed before they can be rendered. A rendering engine is software which generates graphics from data. The world contains everything the user can interact with. The interaction is done through the HTML5 Canvas element. User interaction events are received from the canvas element in the form of "The user clicked at this (x, y) position," or "The user currently has two fingers on the screen at (x1, y1) and (x2, y2)". The GraphDrawer needs to convert the screen coordinates to world coordinates, and then decide if the given event at the given world position has any meaning for the state of the world. The coordinate conversion is done by the camera.
\\[11pt]
The world consists of two types of entities, nodes (vertices) and edges. Entities are stored in arrays on the GraphDrawer object. Nodes are drawn as either a circle or a square. A node needs to specify its position in the world, which is stored on the node object as the properties \code{x} and \code{y}. It also needs to store information about how large it is, which is stored in the \code{w} and \code{h} properties. If the node is a circle, then \code{w} and \code{h} should have the same value, and the value should be the circle radius. If it is an ellipse, then the \code{w} is the radius along the x-axis, and the \code{h} is the radius along the y-axis. A node needs a value, stored in the \code{v} property. This can be text, a number, or a combination of text and numbers. GraphDrawer will only render nodes if they have the \code{x}, \code{y}, \code{w}, \code{h} and \code{v} properties. There are also several optional properties a node can have. \code{selected} is a boolean used by a controller to indicate whether a node has been selected (\code{true}) or not (\code{false}). \code{culled} is a boolean used by the camera to indicate whether a node should be drawn (\code{false}) or not (\code{true}). \code{fillColor} decides what color is used to render the inner part of the node. If it is undefined, white is used. \code{strokeColor} decides what color will be used to render the outline of a node. If it is undefined, black is used.
\\[11pt]
Edges are used to link nodes together. An edge needs to have two properties, \code{n1} and \code{n2}, which are references to the nodes being linked by the edge. Edges are drawn as either a line or an arrow, between the two nodes. If the edge has the property \code{directed} with the value \code{true}, an arrow is drawn pointing from \code{n1} at \code{n2}. If \code{directed} is \code{false} or \code{undefined}, a line is drawn. The \code{strokeColor} property decides which color will be used to draw the line/arrow. If it is undefined, black is used. An edge can also have the \code{v} property. \code{v} represents the cost of going from \code{n1} to \code{n2} (and from \code{n2} to \code{n1} if \code{directed} is \code{undefined} or \code{false}). \code{v} should be a number, and its value is drawn next to the line/arrow.
\\[11pt]
To render the world, three objects are needed, the world, a camera, and a HTML5 canvas. The world has information about the entities. The camera is used to decide which entities need to be drawn to the canvas. Two additional canvases are created, such that drawing the world is easier. The drawing buffer \code{drawBuffer} and the static buffer \code{staticBuffer}. The drawing buffer size is five times greater than the canvas, and the static buffer is the same size as the canvas. These objects are needed because the world might be larger than what is possible to display on a single webpage. The canvas decides how much of the webpage is used to render the world. The camera can then be moved around to display different parts of the world. When the GraphDrawer starts, an interval is started which lets the GraphDrawer update 60 times every second. Each time the GraphDrawer has the opportunity to update is called a frame. Because the application is designed to be used by both phones and computers, computationally expensive and time-consuming operations should be avoided if possible. For this reason, the GraphDrawer will often discard frames. Discarding frames means that no operation is performed, even though the opportunity to do something was there. The update function is called once per frame. If the \code{dirty} property is \code{false}, the frame is discarded. The GraphDrawer will only set the \code{dirty} property to \code{true} once, at startup, so the initial state is rendered. Afterward, a controller has to tell the GraphDrawer to not discard the next frame by setting \code{dirty} to \code{true}. The \code{dirty} property makes it possible to have a responsive user interface, and save CPU time at the same time. When a frame is not discarded, the world is redrawn. This is done in several steps:
\begin{enumerate}
    \item The canvas is cleared. This is done to prevent entities from appearing at two positions at the same time.
    \item Nodes and edges are drawn to a drawing buffer (\code{drawBuffer}). This is done by the GraphDrawer.
    \item The user interface is drawn to a separate buffer (\code{staticBuffer}). This is done by the GraphDrawer if the \code{operatingMode} is set to \code{Presentation}, or by a controller if the \code{operatingMode} is set to \code{Interactive}. \code{operatingMode} is used by the GraphDrawer and by controllers to decide what kind of user interaction is allowed.
    \item \code{drawBuffer} and \code{staticBuffer} is drawn to the canvas.
\end{enumerate}
Some users of the site could be using old hardware or somehow restrict the performance of their browser. The GraphDrawer is designed to update 60 times per second. This means that every frame is allocated: $ 1000 / 60 = 16.666... $ milliseconds to do the work. If the frame uses more than the allocated time, the user will experience this by having the program not respond for some time. If this happens, then the next frame is discarded, to give the computer time to catch up again. 60 frames per second were picked to balance how smooth the graphics move, and the program performance. If more than ten frames need more than the allocated time, the number of frames per second is lowered by 25\%. By lowering the number of frames per second, the user will still have a responsive program. The movement of the graphics looks normal unless the time per frame is increased significantly.
\\[11pt]
The drawing buffer is used to prevent screen tearing. Screen tearing happens when the world is updated in the middle of drawing the world to the canvas. The result is that some parts of the canvas show the old state of the world, while other parts show the new state. By using a separate buffer for drawing, the user will be shown a complete image of the world at every frame, instead of one which is in the process of being drawn. The user interface uses another buffer because it makes it easier to draw the interface on top of the world, by simply placing the draw statement after the world draw statement. The \code{staticBuffer} uses canvas coordinates to draw, which needs fewer operations to consistently place the interface inside the camera view.
\\[11pt]
To let the user interact with the world, two event listeners are attached to the canvas. \code{mousedown} is used to respond to mouse clicks, and \code{touchstart} is used by touch screens. These listeners use the same callback function. The callback function passes the event to the right handler, depending on handler priority. A handler is a function which takes the event as an argument and returns whether or not it consumed the event. If the event was consumed, it should not be given to any other handler. The priority of the user interface handler should generally be higher than the world handler, but the order is not forced. The GraphDrawer first checks if the user interacted with one of the buttons. If not, then a controller is given the chance to handle the event. Finally, the event is given to the gesture handlers. Gesture handlers are responsible for detecting patterns in user interaction and check if they match a given gesture. The GraphDrawer implements two gestures, pan and zoom. Pan is used to move the camera around the world. A pan gesture happens when the user clicks a mouse button and moves the pointer without releasing the button. This can also happen if the user drags their finger across the canvas. The movement must be larger than a given threshold before the camera starts moving. A zoom gesture is defined as the user dragging two fingers in opposite directions. If the fingers move towards each other, the zoom decreases. If the fingers move away from each other, the zoom increases. The average point between the fingers will remain at the same position relative to the canvas edge. The position of events is stored in different properties of the event object, depending on what type of event it is. To make it simpler to write code that works with all types of events, a helper function \code{setEventOffset} was created to convert event positions to a common format. This function should be used right after receiving an event object, to be sure the position of the event is available in the expected properties.
\\[11pt]
The GraphDrawer constructor takes four arguments, \code{canvas}, \code{locale}, \code{config} and \code{window}. \code{canvas} should be a reference to the HTML Canvas which will be used. \code{locale} should be an object containing references to all of the displayed strings in a given language. \code{config} should be an object containing configuration options. \code{window} should be a reference to the browser window object. The following is a list of all the configuration options available:
\begin{enumerate}
    \item \code{nodeShape}, determines the shape which is used to render the nodes. Possible values are \code{"Circle"} and \code{"Rectangle"}. If no value is given, \code{nodeShape} is set to \code{"Rectangle"}.
    \item \code{controlType}, determines which controller is used by the GraphDrawer. Possible values are the names of the controllers as a string. If no value is given, \code{controlType} is set to \code{"Sort"}.
    \item  \code{operatingMode}, determines if the user can manipulate the world, or view a list of states. Possible values are \code{"Interactive"} and \code{"Presentation"}. If no value is given, \code{operatingMode} is set to \code{"Interactive"}.
    \item \code{displayEdgeValues}, enables the \code{v} (value) property of edges. The value will be drawn next to the edge and can be modified if the \code{operatingMode} is set to \code{"Interactive"}. If no value is given, \code{displayEdgeValues} is set to \code{true}.
    \item \code{directedEdges}, enables drawing of edges as arrows instead of lines. If it is set to \code{true} then all edges which does not have the \code{directed} property set to \code{false} are drawn as an arrow instead. If no value is given, \code{directedEdges} is set to \code{false}.
\end{enumerate}
To determine the position and size of a canvas, it is not enough to define the size in the CSS. If the size defined by the CSS is different from the width and height properties of the canvas, the image will be stretched to fit the size defined by the CSS. Because the application is going to be used by screens of any size, the canvas size needs to scale with the screen size. To achieve this, the update function will check if the width of the canvas matches the \code{clientWidth} property. The \code{clientWidth} property is how much space the canvas has been given on the screen. If they do not match, then the size properties of the canvas need to be changed. The width is set to the same value as \code{clientWidth}. The height is determined by the screen aspect ratio and the canvas width. By using the aspect ratio, the canvas has a greater height than width on mobile devices, and a smaller height on computers.
\\[11pt]
When the size of the canvas is changed, the size of the \code{drawBuffer} and \code{staticBuffer} also need to change. Because they are also canvases, this is simply done by updating the width and height properties. After the width or height property of a canvas is changed, any data drawn to it is cleared. The \code{drawBuffer} can be fixed by setting the \code{dirty} value to \code{true}, because this will make the GraphDrawer redraw the world. The \code{staticBuffer} is usually not redrawn every frame, e.g., the buttons to navigate between algorithm steps, and is not part of the draw function. To redraw the \code{staticBuffer}, every object on it needs to get a new position and be redrawn right after changing the canvas size. The camera keeps a reference to the size of the canvas in its \code{viewportHeight} and \code{viewportWidth} properties. If these are not changed, the resulting image is stretched. 
\\[11pt]
After resizing the canvas, the \code{drawBuffer} can be too large, if the user has a screen with a very large resolution, e.g., above 4K. Browsers have different limits, but based on numbers from Mozilla \cite{CanvasMaxSize} and Chromium \cite{CanvasMaxSizeChromeium}, modern browsers have a width and height limit of 32767 pixels for the canvas element. If this limit is exceeded then depending on the browser, the canvas can stop working, the site can stop working, or the browser can crash. The actual limit seems to be much lower than 32767 pixels. The canvas slowed down significantly when the width was larger than 7000 pixels, and completely stopped working when the width was larger than 8500 pixels. The website was viewed on a modern version (v73.0.3683.103) of the Chrome browser. To be sure that the size of the canvas won't prevent the GraphDrawer from working, a limit of 7000 pixels has been implemented.
\\[11pt]
The position of an arrow from one node to another node depends on the shape of the node it is pointing at. If the node is a circle, then the arrow is drawn at the circumference. This is done by creating a line between the two nodes and checking where it intersects the circle. Rectangle nodes have four defined positions for the arrow, one at the center of every edge. To figure out which point to use, the angle (in degrees) between the nodes is used. The angle is calculated from the x-axis and increases counterclockwise. The edge is picked based on the following criteria:
\begin{enumerate}
    \item If the angle is between 45 and 135 degrees, the point at the top edge is picked.
    \item If the angle is between 135 and 225 degrees, the point at the left edge is picked.
    \item If the angle is between 225 and 315 degrees, the point at the bottom edge is picked.
    \item If no edge has been picked, the point at the right edge is picked.
\end{enumerate}
Developers can add or remove features from the GraphDrawer by creating controller objects. Controller objects are used to modify the user interaction and the world presentation. They can interrupt the GraphDrawer at pre-determined states. It is also possible to create custom interrupts by creating timers (\code{setTimeout}, \code{setInterval}) or by adding event handlers to the canvas object. The controller interface is simple by design and only requires two methods. There are also some optional methods which can be implemented to add more functionality.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{/graphdrawer/controllerlifecycle}
    \caption{Graphdrawer - controller interaction}
    \label{fig:graphdrawerControllerLifeCycle}
\end{figure}
\begin{enumerate}
    \item Required: The controller constructor. The constructor should take two arguments. The first being a reference to the GraphDrawer, and the second being an optional configuration object.
    \item Required: \code{export()}, should return an object. The \code{export} method is called when the system wants to retrieve an answer or solution from the GraphDrawer. The returned object should be a representation of the world, which can be understood by one of the algorithm implementations, or by a solution checker function.
    \item Required: \code{mouseDownHandler(e)}, should return \code{true} or \code{false}. The \code{mouseDownHandler()} is called when the user clicks or touches the canvas. It is called with the event as the first and only argument. \code{mouseDownHandler()} should return \code{true} if the event was handled and should be consumed, or \code{false} if it was ignored.
    \item Optional: \code{configure()}. If the controller was given a configuration object at instantiation, then the \code{configure()} method should be implemented. It is called when the GraphDrawer changes controller.
    \item Optional: \code{dirtyUpdate()}. \code{dirtyUpdate()} is called right before the world is rendered and drawn to the screen.
    \item Optional: \code{parseSteps()} and the \code{steps} property. If the \code{operationMode} of the GraphDrawer is set to \code{"Presentation"}, then the controller is expected to have a list of steps in the \code{steps} property of the controller. The user can navigate through the list. \code{parseSteps()} is called every time the user changes the viewed step. The index of the viewed step is stored in the GraphDrawer property \code{currentStep}.
    \item Optional: \code{onCanvasResize()}. Anything drawn by a controller to the \code{staticBuffer} is cleared when the canvas is resized. If the controller needs to redraw when the canvas size changes, the \code{onCanvasResize()} function can be implemented. It is called when the canvas has a new and valid size. 
\end{enumerate}
Even though the controllers allows for configuration, not all of the configuration can be changed when the GraphDrawer component is included. E.g., Dijkstra start and end colors are defined inside the component, and not as a property on the component. This is done to enforce a consistent style in the application. If it were possible to change the colors every time the GraphDrawer was included on a page, it would be confusing for the users. The colors can be changed in the component definition, but they have to be the same for the entire application.

\input{sections/construction/graphdrawer/camera.tex}

\input{sections/construction/graphdrawer/controllers/graph0.tex}

\input{sections/construction/graphdrawer/controllers/sort.tex}

\input{sections/construction/graphdrawer/controllers/dijkstra.tex}

\input{sections/construction/graphdrawer/controllers/python.tex}

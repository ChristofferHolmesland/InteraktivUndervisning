\subsection{GraphDrawer}
To solve the problem of letting students visually answer questions, GraphDrawer was created. GraphDrawer is the name of a VueJS component which is used to display graphics to the user. It is implemented as an software engine (https://en.wikipedia.org/wiki/Software\_engine), which means that it is responsible for rendering the world and handling user interaction. 
\\[11pt]
The world consists of two types of entities, nodes (vertices) and edges. Entities are stored in arrays on the GraphDrawer object. Nodes are drawn as either a circle or a square. A node needs to specify its position in the world, which is stored on the node object as the properties $x$ and $y$. It also needs to store information about how large it is, which is stored in the $r$ property. $r$ represents either the circle radius, or the length of each side of the square. A node needs a value, stored in the $v$ property. This can be text, a number, or a combination of text and numbers. GraphDrawer will only render nodes if they have the $x$, $y$, $r$ and $v$ properties. There are also several optional properties a node can have. $selected$ is a boolean used by a controller to indicate whether a node has been selected ($true$) or not ($false$). $culled$ is a boolean used by the camera to indicate whether a node has been culled ($true$) or not ($false$). $fillColor$ decides what color will be used to render the inner part of the node. If it's undefined, white will be used. $strokeColor$ decides  what color will be used to render the outline of a node. If it's undefined, black will be used. Edges are used to link nodes together. An edge needs to have two properties, $n1$ and $n2$, which are references to the nodes being linked by the edge. Edges are drawn as either a line or an arrow, between the two nodes. If the edge has the property $directed$ with the value $true$, an arrow will be drawn pointing from $n1$ at $n2$. If $directed$ is $false$ or $undefined$, a line is drawn. The $strokeColor$ property decides which color will be used to draw the line/arrow. If it's undefined, black is used. An edge can also have the $v$ property. $v$ represents the cost of going from $n1$ to $n2$ (and from $n2$ to $n1$ if $directed$ is $undefined$ or $false$). $v$ should be a number, and its value will be drawn next to the line/arrow.
\\[11pt]
To render the world, three objects are needed, the world, a camera and a HTML5 canvas. The world has information about the entities. The camera is used to decide which entities need to be drawn to the canvas. These objects are needed because the world might be larger than what is possible to display on a single webpage. The canvas decides how much of the webpage is used to render the world. The camera can then be moved around to display different parts of the world. When the GraphDrawer starts, an interval is started which lets the GraphDrawer update 60 times every second. Each time the GraphDrawer has the opportunity to update, is called a frame. Because the application is designed to be used by both phones and computers, computationally expensive and time consuming operations should be avoided if possible. For this reason the GraphDrawer will often discard frames. Discarding frames means that no operation is performed, even though the opportunity to do something was there. The update function is called once per frame. If the $dirty$ property is $false$, the frame is discarded. The GraphDrawer will only set the $dirty$ property to $true$ once, at startup, so the initial state is rendered. Afterwards a controller has to tell the GraphDrawer to not discard the next frame by setting $dirty$ to $true$. The $dirty$ property makes it possible to have a responsive user interface, and save CPU time at the same time. When a frame isn't discarded, the world will be redrawn. This is done in several steps:
\begin{enumerate}
    \item The canvas is cleared. This is done to prevent entities to appear at two positions at the same time.
    \item Nodes and edges are drawn to a drawing buffer ($drawBuffer$). This is done by the GraphDrawer.
    \item The user interface is drawn to a separate buffer ($staticBuffer$). This is done by the GraphDrawer if the $operatingMode$ is set to $Presentation$, or by a controller if the $operatingMode$ is set to $Interactive$. $operatingMode$ is used by the GraphDrawer and by controllers to decide what kind of user interaction is allowed.
    \item $drawBuffer$ and $staticBuffer$ is drawn to the canvas.
\end{enumerate}
The drawing buffer is used to prevent screen tearing (https://en.wikipedia.org/wiki/Screen\_tearing). By using a seperate buffer for drawing, the user will be shown a complete image of the world at every frame, instead of one which is in the process of being drawn. Another buffer is used by the user interface because it makes it easier to draw the interface on top of the world, by simply placing the draw statement after the world draw statement. The $staticBuffer$ uses canvas coordinates to draw, which needs less operations to consistently place the interface inside the cameras view.
\\[11pt]
To let the user interact with the world...

\input{sections/construction/graphdrawer/camera.tex}

\input{sections/construction/graphdrawer/controllers/graph0.tex}

\input{sections/construction/graphdrawer/controllers/sort.tex}

\input{sections/construction/graphdrawer/controllers/dijkstra.tex}
